<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>OpenPDF</title>
  <style>
    /* Global styles */
    body {
      font-family: system-ui, sans-serif;
      margin: 0;
      line-height: 1.6;
    }
    
    .container {
      width: 100%;
      max-width: 40rem;
      margin: 0 auto;
      padding: 2rem;
      box-sizing: border-box;
    }

    #app-content {
      width: 100%;
    }

    h1 {
      margin-bottom: 1.5rem;
    }

    .examples {
      margin-top: 2rem;
      padding: 1rem;
      background-color: #f5f5f5;
      border-radius: 4px;
      width: 100%;
      box-sizing: border-box;
    }

    /* Alert component */
    #alert-container {
      width: 100%;
    }
    
    .alert {
      width: 100%;
      padding: 1rem;
      border-radius: 4px;
      margin-bottom: 1.5rem;
      box-sizing: border-box;
    }
    
    .alert-error {
      background-color: #ffebee;
      color: #c62828;
      border: 1px solid #ef9a9a;
    }
    
    .alert-warning {
      background-color: #fff8e1;
      color: #f57f17;
      border: 1px solid #ffe082;
    }
    
    .alert-success {
      background-color: #e8f5e9;
      color: #2e7d32;
      border: 1px solid #a5d6a7;
    }

    /* DOI form */
    .doi-form {
      margin: 2rem 0;
      width: 100%;
    }
    
    input {
      width: 100%;
      padding: 0.75rem;
      margin-bottom: 1rem;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 1rem;
      box-sizing: border-box;
    }
    button {
      background: #4a69bd;
      color: white;
      border: none;
      padding: 0.75rem 1.5rem;
      border-radius: 4px;
      font-size: 1rem;
      cursor: pointer;
    }
    button:hover {
      background: #1e3799;
    }
    
    /* Publication metadata */
    #metadata-container {
      margin-top: 2rem;
      border: 1px solid #e0e0e0;
      border-radius: 4px;
      padding: 1.5rem;
      background-color: #f9f9f9;
      display: none;
    }
    
    .metadata-title {
      font-size: 1.25rem;
      font-weight: 600;
      margin-bottom: 1rem;
    }
    
    .metadata-row {
      display: flex;
      margin-bottom: 0.5rem;
      align-items: flex-start;
    }
    
    .metadata-label {
      font-weight: 600;
      min-width: 120px;
      margin-right: 1rem;
    }
    
    .metadata-value {
      flex: 1;
    }
    
    .oa-badge {
      display: inline-block;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      font-size: 0.875rem;
      font-weight: 600;
    }
    
    .oa-gold {
      background-color: #ffd700;
      color: #333;
    }
    
    .oa-green {
      background-color: #4caf50;
      color: white;
    }
    
    .oa-bronze {
      background-color: #cd7f32;
      color: white;
    }
    
    .oa-closed {
      background-color: #9e9e9e;
      color: white;
    }
    
    .access-button {
      display: inline-block;
      padding: 0.75rem 1rem;
      width: 100%;
      max-width: 100px;
      margin-bottom: 0.5rem;
      border-radius: 4px;
      text-decoration: none;
      font-weight: 500;
      transition: background-color 0.2s;
      text-align: center;
    }
    
    .oa-button {
      background-color: #4caf50;
      color: white;
    }
    
    .oa-button:hover {
      background-color: #388e3c;
    }
    
    .publisher-button {
      background-color: #2196f3;
      color: white;
    }
    
    .publisher-button:hover {
      background-color: #1976d2;
    }
    
    .no-access {
      display: inline-block;
      padding: 0.75rem 1rem;
      background-color: #f5f5f5;
      color: #757575;
      border: 1px dashed #bdbdbd;
      border-radius: 4px;
      font-style: italic;
    }
  </style>
</head>
<body>
  <div class="container">
    <div id="app-content">
      <h1>OpenPDF</h1>
      <h3>Find the PDF for Open Access publications</h3>
      
      <div id="alert-container"></div>
      
      <div id="metadata-container">
        <div class="metadata-title">Publication Information</div>
        <div id="metadata-content"></div>
      </div>
      
      <p>
        Enter a DOI or DOI URL to directly get the full-text PDF. For non-Open Access publications, you'll be redirected to the publisher's website.
      </p>

      <form id="doi-form" class="doi-form">
        <input
          type="text"
          id="doi-input"
          placeholder="Enter 10.4018/IJWLTT.20211101.oa4 or https://doi.org/10.4018/IJWLTT.20211101.oa4"
          required
        />
        <button type="submit">Find PDF</button>
      </form>
    </div>
  </div>

  <script>
    // DOI regex for validation
    const doiRegex = () => {
      return /\b(10\.[0-9]{3,}(?:\.[0-9]+)*\/(?:(?![\"&\'])\S)+)\b/gi;
    };

    // Get URL parameters helper
    function getUrlParams() {
      const searchParams = new URLSearchParams(window.location.search);
      return {
        error: searchParams.get('error'),
        doi: searchParams.get('doi'),
        success: searchParams.get('success'),
        message: searchParams.get('message')
      };
    }

    // Show alert message
    function showAlert(message, type = 'error') {
      const alertContainer = document.getElementById('alert-container');
      
      // Sanitize inputs to prevent XSS
      const sanitizedType = type.replace(/[^\w-]/g, '');
      const sanitizedMessage = document.createTextNode(message);
      
      const alertDiv = document.createElement('div');
      alertDiv.className = `alert alert-${sanitizedType}`;
      alertDiv.appendChild(sanitizedMessage);
      
      alertContainer.innerHTML = '';
      alertContainer.appendChild(alertDiv);
    }

    // Handle form submission
    document.getElementById('doi-form').addEventListener('submit', async function(event) {
      event.preventDefault();
      
      const doiInput = document.getElementById('doi-input').value.trim();
      
      // Check if input is empty
      if (!doiInput) {
        showAlert('Please enter a DOI before submitting.');
        return;
      }
      
      // Validate DOI
      const match = doiInput.match(doiRegex());
      if (!match) {
        showAlert('The provided input does not appear to be a valid DOI. Please check and try again.');
        return;
      }
      
      const extractedDoi = match[0];
      
      try {
        // Show loading state
        showAlert('Looking up DOI...', 'success');
        
        // Fetch data from OpenAlex
        const work = await getOpenAlexWork(extractedDoi);
        const pdfUrl = await findPdfUrl(work);
        
        // Check if there's a PDF or publisher URL
        const primaryUrl = work.primary_location?.landing_page_url;
        
        if (!pdfUrl && !primaryUrl) {
          showAlert(`No PDF or publisher link found for DOI: ${extractedDoi}. The article might not be properly indexed.`, 'error');
        } else if (!pdfUrl) {
          showAlert(`This article is not available as Open Access.`, 'warning');
        } else {
          showAlert(`PDF available for this Open Access publication.`, 'success');
        }
        
        // Display metadata with access links
        displayMetadata(work, pdfUrl, primaryUrl);
        
      } catch (error) {
        showAlert(`Failed to resolve DOI: ${extractedDoi}. ${error.message || 'Unknown error'}`);
      }
    });

    // Handle DOM content loaded
    document.addEventListener('DOMContentLoaded', function() {
      // Check URL parameters
      const params = getUrlParams();
      
      if (params.doi && params.doi.trim()) {
        // Sanitize DOI parameter before setting value
        const sanitizedDoi = params.doi.replace(/[<>"'&]/g, '');
        document.getElementById('doi-input').value = sanitizedDoi;
        // Auto-submit the form if a DOI parameter is present and not empty
        document.getElementById('doi-form').dispatchEvent(new Event('submit'));
      }
      
      if (params.success === 'true' && params.doi) {
        // Sanitize DOI in alert message
        const sanitizedDoi = params.doi.replace(/[<>"'&]/g, '');
        showAlert(`Successfully found PDF for DOI: ${sanitizedDoi}`, 'success');
      } else if (params.error) {
        let alertMessage = '';
        // Sanitize any user-provided data from URL parameters
        const sanitizedDoi = params.doi ? params.doi.replace(/[<>"'&]/g, '') : 'Unknown';
        const sanitizedMessage = params.message ? params.message.replace(/[<>"'&]/g, '') : 'Please try again later.';
        
        switch(params.error) {
          case 'invalid-doi':
            alertMessage = 'The provided input does not appear to be a valid DOI. Please check and try again.';
            break;
          case 'no-pdf-found':
            alertMessage = `No PDF or publisher location found for DOI: ${sanitizedDoi}. The article might not be indexed correctly.`;
            break;
          case 'failed-to-resolve':
            alertMessage = `Failed to resolve DOI: ${sanitizedDoi}. ${sanitizedMessage}`;
            break;
          default:
            alertMessage = 'An unknown error occurred. Please try again.';
        }
        showAlert(alertMessage);
      }
      
      // Check if we have a DOI in the hash
      const hashDoi = window.location.hash.replace('#', '');
      if (hashDoi && hashDoi.trim()) {
        try {
          const decodedHash = decodeURIComponent(hashDoi);
          const match = decodedHash.match(doiRegex());
          if (match) {
            // Sanitize DOI from hash before setting value
            const sanitizedDoi = match[0].replace(/[<>"'&]/g, '');
            document.getElementById('doi-input').value = sanitizedDoi;
            document.getElementById('doi-form').dispatchEvent(new Event('submit'));
          }
        } catch (e) {
          console.error('Error processing hash DOI:', e);
        }
      }
    });

    // OpenAlex API functions
    // Function to display publication metadata
    function displayMetadata(work, pdfUrl, publisherUrl) {
      const metadataContainer = document.getElementById('metadata-container');
      const metadataContent = document.getElementById('metadata-content');
      
      // Clear previous content
      metadataContent.innerHTML = '';
      
      // Show the container
      metadataContainer.style.display = 'block';
      
      // Function to create a metadata row
      function createMetadataRow(label, value) {
        const row = document.createElement('div');
        row.className = 'metadata-row';
        
        const labelDiv = document.createElement('div');
        labelDiv.className = 'metadata-label';
        labelDiv.textContent = label;
        
        const valueDiv = document.createElement('div');
        valueDiv.className = 'metadata-value';
        
        // If value contains HTML (for links), set it safely
        if (typeof value === 'string' && (value.includes('<a ') || value.includes('<span '))) {
          valueDiv.innerHTML = value;
        } else {
          valueDiv.textContent = value;
        }
        
        row.appendChild(labelDiv);
        row.appendChild(valueDiv);
        return row;
      }
      
      // Function to format date
      function formatDate(dateString) {
        if (!dateString) return 'Unknown';
        try {
          const date = new Date(dateString);
          return date.toLocaleDateString('en-US', { 
            year: 'numeric', 
            month: 'long', 
            day: 'numeric' 
          });
        } catch (e) {
          return dateString;
        }
      }
      
      // Function to get OA status badge
      function getOaBadge(oaStatus) {
        // Create badge element
        const badge = document.createElement('span');
        badge.className = 'oa-badge';
        
        if (!oaStatus) {
          badge.classList.add('oa-closed');
          badge.textContent = 'Closed';
          return badge.outerHTML;
        }
        
        // Validate and sanitize oaStatus
        const validStatuses = ['gold', 'green', 'bronze'];
        const sanitizedStatus = validStatuses.includes(oaStatus) ? oaStatus : 'closed';
        
        let badgeClass = '';
        switch(sanitizedStatus) {
          case 'gold':
            badgeClass = 'oa-gold';
            break;
          case 'green':
            badgeClass = 'oa-green';
            break;
          case 'bronze':
            badgeClass = 'oa-bronze';
            break;
          default:
            badgeClass = 'oa-closed';
        }
        
        badge.classList.add(badgeClass);
        badge.textContent = sanitizedStatus.charAt(0).toUpperCase() + sanitizedStatus.slice(1);
        
        return badge.outerHTML;
      }
      
      // Clear previous content
      metadataContent.innerHTML = '';

      // Create and append each metadata row
      
      // PDF Access row - always show, but with different content based on availability
      if (pdfUrl) {
        // Sanitize URL
        const sanitizedPdfUrl = encodeURI(pdfUrl);
        const pdfLink = `
          <a href="${sanitizedPdfUrl}" target="_blank" rel="noopener noreferrer" class="access-button oa-button">
            Open PDF
          </a>
        `;
        metadataContent.appendChild(createMetadataRow('PDF Link', pdfLink));
      } else {
        metadataContent.appendChild(createMetadataRow('PDF Link', `
          <span class="no-access">No direct link available</span>
        `));
      }
      
      if (publisherUrl) {
        // Sanitize URL
        const sanitizedPublisherUrl = encodeURI(publisherUrl);
        const publisherLink = `
          <a href="${sanitizedPublisherUrl}" target="_blank" rel="noopener noreferrer" class="access-button publisher-button">
            Publisher
          </a>
        `;
        metadataContent.appendChild(createMetadataRow('Publisher', publisherLink));
      }
      
      // Title
      metadataContent.appendChild(createMetadataRow('Title', work.title || 'Unknown Title'));
      
      // Authors
      const authors = work.authorships?.map(a => a.author?.display_name).filter(Boolean).join(', ') || 'Unknown';
      metadataContent.appendChild(createMetadataRow('Authors', authors));
      
      // Publication date
      metadataContent.appendChild(createMetadataRow('Published', formatDate(work.publication_date)));
      
      // Journal/venue
      const venue = work.primary_location?.source?.display_name || work.host_venue?.display_name || 'Unknown';
      metadataContent.appendChild(createMetadataRow('Journal', venue));
      
      // Open access status
      metadataContent.appendChild(createMetadataRow('Access Status', getOaBadge(work.open_access?.oa_status)));
    }
    
    async function getOpenAlexWork(doi) {
      const encodedDoi = encodeURIComponent(doi);
      try {
        const response = await fetch(`https://api.openalex.org/works/https://doi.org/${encodedDoi}`);
        
        if (!response.ok) {
          if (response.status === 404) {
            throw new Error(`DOI not found in OpenAlex database (${response.status})`);
          } else if (response.status === 429) {
            throw new Error(`OpenAlex API rate limit exceeded (${response.status}). Please try again later.`);
          } else if (response.status >= 500) {
            throw new Error(`OpenAlex server error (${response.status}). Please try again later.`);
          } else {
            throw new Error(`Failed to fetch from OpenAlex: ${response.status}`);
          }
        }
        
        const data = await response.json();
        
        // Check if OpenAlex found the work but it's a placeholder/error response
        if (data.id === null || data.error) {
          throw new Error(`Article metadata not available in OpenAlex: ${data.error || 'Unknown error'}`);
        }
        
        return data;
      } catch (error) {
        // Enhance network/fetch errors
        if (error.name === 'TypeError' && error.message.includes('fetch')) {
          throw new Error(`Network error when connecting to OpenAlex. Please check your internet connection.`);
        }
        throw error;
      }
    }

    async function findPdfUrl(work) {
      // Use OpenAlex's best_oa_location pdf_url if available
      if (work.best_oa_location?.pdf_url) {
        return work.best_oa_location.pdf_url;
      }
      
      return null;
    }
  </script>
</body>
</html>